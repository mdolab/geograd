!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
!
MODULE TRIANGLES_D
  IMPLICIT NONE
  REAL(kind=8), PARAMETER :: one=1.0
  REAL(kind=8), PARAMETER :: zero=0.0

CONTAINS
!  Differentiation of point_tri in forward (tangent) mode:
!   variations   of useful results: d
!   with respect to varying inputs: p a b c
!   RW status of diff variables: d:out p:in a:in b:in c:in
  SUBROUTINE POINT_TRI_D(a, ad, b, bd, c, cd, p, pd, d, dd)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: a, b, c, p
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: ad, bd, cd, pd
    REAL(kind=8), INTENT(OUT) :: d
    REAL(kind=8), INTENT(OUT) :: dd
    REAL(kind=8), DIMENSION(3) :: ab, ac, ap, bp, cp, closepoint, diff, &
&   dummydiff
    REAL(kind=8), DIMENSION(3) :: abd, acd, apd, bpd, cpd, closepointd, &
&   diffd, dummydiffd
    REAL(kind=8) :: d1, d2, d3, d4, d5, d6
    REAL(kind=8) :: d1d, d2d, d3d, d4d, d5d, d6d
    REAL(kind=8) :: v, vc, vb, va, w, denom
    REAL(kind=8) :: vd, vcd, vbd, vad, wd, denomd
    INTRINSIC SQRT
    abd = bd - ad
    ab = b - a
    acd = cd - ad
    ac = c - a
    apd = pd - ad
    ap = p - a
    CALL DOT_PROD_D(d1, d1d, ab, abd, ap, apd)
    CALL DOT_PROD_D(d2, d2d, ac, acd, ap, apd)
    IF (d1 .LE. zero .AND. d2 .LE. zero) THEN
! barycentric 1, 0, 0
      closepointd = ad
      closepoint = a
      diffd = closepointd - pd
      diff = closepoint - p
      dummydiffd = diffd
      dummydiff = diff
      CALL DOT_PROD_D(d, dd, diff, diffd, dummydiff, dummydiffd)
      IF (d .EQ. 0.0) THEN
        dd = 0.0_8
      ELSE
        dd = dd/(2.0*SQRT(d))
      END IF
      d = SQRT(d)
      RETURN
    ELSE
! check if P in vertex region outside B
      bpd = pd - bd
      bp = p - b
      CALL DOT_PROD_D(d3, d3d, ab, abd, bp, bpd)
      CALL DOT_PROD_D(d4, d4d, ac, acd, bp, bpd)
      IF (d3 .GE. zero .AND. d4 .LE. d3) THEN
! barycentric 0, 1, 0
        closepointd = bd
        closepoint = b
        diffd = closepointd - pd
        diff = closepoint - p
        dummydiffd = diffd
        dummydiff = diff
        CALL DOT_PROD_D(d, dd, diff, diffd, dummydiff, dummydiffd)
        IF (d .EQ. 0.0) THEN
          dd = 0.0_8
        ELSE
          dd = dd/(2.0*SQRT(d))
        END IF
        d = SQRT(d)
        RETURN
      ELSE
! check if P in edge region of AB, if so return projection of P onto AB
        vcd = d1d*d4 + d1*d4d - d3d*d2 - d3*d2d
        vc = d1*d4 - d3*d2
        IF (vc .LE. zero .AND. d1 .GE. zero .AND. d3 .LE. zero) THEN
          vd = (d1d*(d1-d3)-d1*(d1d-d3d))/(d1-d3)**2
          v = d1/(d1-d3)
! barycentric coordinates (1-v,v,0)
          closepointd = ad + vd*ab + v*abd
          closepoint = a + v*ab
          diffd = closepointd - pd
          diff = closepoint - p
          dummydiffd = diffd
          dummydiff = diff
          CALL DOT_PROD_D(d, dd, diff, diffd, dummydiff, dummydiffd)
          IF (d .EQ. 0.0) THEN
            dd = 0.0_8
          ELSE
            dd = dd/(2.0*SQRT(d))
          END IF
          d = SQRT(d)
          RETURN
        ELSE
! Check if P in vertex region C
          cpd = pd - cd
          cp = p - c
          CALL DOT_PROD_D(d5, d5d, ab, abd, cp, cpd)
          CALL DOT_PROD_D(d6, d6d, ac, acd, cp, cpd)
          IF (d6 .GE. zero .AND. d5 .LE. d6) THEN
! barycentric coordinates (0,0,1)
            closepointd = cd
            closepoint = c
            diffd = closepointd - pd
            diff = closepoint - p
            dummydiffd = diffd
            dummydiff = diff
            CALL DOT_PROD_D(d, dd, diff, diffd, dummydiff, dummydiffd)
            IF (d .EQ. 0.0) THEN
              dd = 0.0_8
            ELSE
              dd = dd/(2.0*SQRT(d))
            END IF
            d = SQRT(d)
            RETURN
          ELSE
! check if P in edge region of AC, if so, return proj(P,AC)
            vbd = d5d*d2 + d5*d2d - d1d*d6 - d1*d6d
            vb = d5*d2 - d1*d6
            IF (vb .LE. zero .AND. d2 .GE. zero .AND. d6 .LE. zero) THEN
              wd = (d2d*(d2-d6)-d2*(d2d-d6d))/(d2-d6)**2
              w = d2/(d2-d6)
! barycentric (1-w, 0, w)
              closepointd = ad + wd*ac + w*acd
              closepoint = a + w*ac
              diffd = closepointd - pd
              diff = closepoint - p
              dummydiffd = diffd
              dummydiff = diff
              CALL DOT_PROD_D(d, dd, diff, diffd, dummydiff, dummydiffd)
              IF (d .EQ. 0.0) THEN
                dd = 0.0_8
              ELSE
                dd = dd/(2.0*SQRT(d))
              END IF
              d = SQRT(d)
              RETURN
            ELSE
! Check if P in edge region of BC, if so, return proj(P,BC)
              vad = d3d*d6 + d3*d6d - d5d*d4 - d5*d4d
              va = d3*d6 - d5*d4
              IF (va .LE. zero .AND. d4 - d3 .GE. zero .AND. d5 - d6 &
&                 .GE. zero) THEN
                wd = ((d4d-d3d)*(d4-d3+(d5-d6))-(d4-d3)*(d4d-d3d+d5d-d6d&
&                 ))/(d4-d3+(d5-d6))**2
                w = (d4-d3)/(d4-d3+(d5-d6))
! barycentric (0, 1-w, w)
                closepointd = bd + wd*(c-b) + w*(cd-bd)
                closepoint = b + w*(c-b)
                diffd = closepointd - pd
                diff = closepoint - p
                dummydiffd = diffd
                dummydiff = diff
                CALL DOT_PROD_D(d, dd, diff, diffd, dummydiff, &
&                         dummydiffd)
                IF (d .EQ. 0.0) THEN
                  dd = 0.0_8
                ELSE
                  dd = dd/(2.0*SQRT(d))
                END IF
                d = SQRT(d)
                RETURN
              ELSE
! P inside face region. Compute Q through barycentric (u, v, w)
                denomd = -(one*(vad+vbd+vcd)/(va+vb+vc)**2)
                denom = one/(va+vb+vc)
                vd = vbd*denom + vb*denomd
                v = vb*denom
                wd = vcd*denom + vc*denomd
                w = vc*denom
                closepointd = ad + abd*v + ab*vd + acd*w + ac*wd
                closepoint = a + ab*v + ac*w
                diffd = closepointd - pd
                diff = closepoint - p
                dummydiffd = diffd
                dummydiff = diff
                CALL DOT_PROD_D(d, dd, diff, diffd, dummydiff, &
&                         dummydiffd)
                IF (d .EQ. 0.0) THEN
                  dd = 0.0_8
                ELSE
                  dd = dd/(2.0*SQRT(d))
                END IF
                d = SQRT(d)
                RETURN
              END IF
            END IF
          END IF
        END IF
      END IF
    END IF
  END SUBROUTINE POINT_TRI_D
  SUBROUTINE POINT_TRI(a, b, c, p, d)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: a, b, c, p
    REAL(kind=8), INTENT(OUT) :: d
    REAL(kind=8), DIMENSION(3) :: ab, ac, ap, bp, cp, closepoint, diff, &
&   dummydiff
    REAL(kind=8) :: d1, d2, d3, d4, d5, d6
    REAL(kind=8) :: v, vc, vb, va, w, denom
    INTRINSIC SQRT
    ab = b - a
    ac = c - a
    ap = p - a
    CALL DOT_PROD(d1, ab, ap)
    CALL DOT_PROD(d2, ac, ap)
    IF (d1 .LE. zero .AND. d2 .LE. zero) THEN
! barycentric 1, 0, 0
      closepoint = a
      diff = closepoint - p
      dummydiff = diff
      CALL DOT_PROD(d, diff, dummydiff)
      d = SQRT(d)
      RETURN
    ELSE
! check if P in vertex region outside B
      bp = p - b
      CALL DOT_PROD(d3, ab, bp)
      CALL DOT_PROD(d4, ac, bp)
      IF (d3 .GE. zero .AND. d4 .LE. d3) THEN
! barycentric 0, 1, 0
        closepoint = b
        diff = closepoint - p
        dummydiff = diff
        CALL DOT_PROD(d, diff, dummydiff)
        d = SQRT(d)
        RETURN
      ELSE
! check if P in edge region of AB, if so return projection of P onto AB
        vc = d1*d4 - d3*d2
        IF (vc .LE. zero .AND. d1 .GE. zero .AND. d3 .LE. zero) THEN
          v = d1/(d1-d3)
! barycentric coordinates (1-v,v,0)
          closepoint = a + v*ab
          diff = closepoint - p
          dummydiff = diff
          CALL DOT_PROD(d, diff, dummydiff)
          d = SQRT(d)
          RETURN
        ELSE
! Check if P in vertex region C
          cp = p - c
          CALL DOT_PROD(d5, ab, cp)
          CALL DOT_PROD(d6, ac, cp)
          IF (d6 .GE. zero .AND. d5 .LE. d6) THEN
! barycentric coordinates (0,0,1)
            closepoint = c
            diff = closepoint - p
            dummydiff = diff
            CALL DOT_PROD(d, diff, dummydiff)
            d = SQRT(d)
            RETURN
          ELSE
! check if P in edge region of AC, if so, return proj(P,AC)
            vb = d5*d2 - d1*d6
            IF (vb .LE. zero .AND. d2 .GE. zero .AND. d6 .LE. zero) THEN
              w = d2/(d2-d6)
! barycentric (1-w, 0, w)
              closepoint = a + w*ac
              diff = closepoint - p
              dummydiff = diff
              CALL DOT_PROD(d, diff, dummydiff)
              d = SQRT(d)
              RETURN
            ELSE
! Check if P in edge region of BC, if so, return proj(P,BC)
              va = d3*d6 - d5*d4
              IF (va .LE. zero .AND. d4 - d3 .GE. zero .AND. d5 - d6 &
&                 .GE. zero) THEN
                w = (d4-d3)/(d4-d3+(d5-d6))
! barycentric (0, 1-w, w)
                closepoint = b + w*(c-b)
                diff = closepoint - p
                dummydiff = diff
                CALL DOT_PROD(d, diff, dummydiff)
                d = SQRT(d)
                RETURN
              ELSE
! P inside face region. Compute Q through barycentric (u, v, w)
                denom = one/(va+vb+vc)
                v = vb*denom
                w = vc*denom
                closepoint = a + ab*v + ac*w
                diff = closepoint - p
                dummydiff = diff
                CALL DOT_PROD(d, diff, dummydiff)
                d = SQRT(d)
                RETURN
              END IF
            END IF
          END IF
        END IF
      END IF
    END IF
  END SUBROUTINE POINT_TRI
!  Differentiation of line_line in forward (tangent) mode:
!   variations   of useful results: d
!   with respect to varying inputs: p1 p2 q1 q2
!   RW status of diff variables: d:out p1:in p2:in q1:in q2:in
  SUBROUTINE LINE_LINE_D(p1, p1d, q1, q1d, p2, p2d, q2, q2d, d, dd)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: p1, q1, p2, q2
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: p1d, q1d, p2d, q2d
    REAL(kind=8), INTENT(OUT) :: d
    REAL(kind=8), INTENT(OUT) :: dd
    REAL(kind=8), DIMENSION(3) :: d1, d2, r, diff, c1, c2, dummy3
    REAL(kind=8), DIMENSION(3) :: d1d, d2d, rd, diffd, c1d, c2d, dummy3d
    REAL(kind=8), PARAMETER :: eps=1e-12
    REAL(kind=8) :: a, b, c, e, f, s, t, denom
    REAL(kind=8) :: ad, bd, cd, ed, fd, sd, td, denomd
    INTRINSIC SQRT
    d1d = q1d - p1d
    d1 = q1 - p1
    d2d = q2d - p2d
    d2 = q2 - p2
    rd = p1d - p2d
    r = p1 - p2
    dummy3d = d1d
    dummy3 = d1
    CALL DOT_PROD_D(a, ad, d1, d1d, dummy3, dummy3d)
    dummy3d = d2d
    dummy3 = d2
    CALL DOT_PROD_D(e, ed, d2, d2d, dummy3, dummy3d)
    CALL DOT_PROD_D(f, fd, d2, d2d, r, rd)
    IF (a .LE. eps .AND. e .LE. eps) THEN
! both segments degenrate into points
      diffd = q1d - p1d
      diff = q1 - p1
      dummy3d = diffd
      dummy3 = diff
      CALL DOT_PROD_D(d, dd, diff, diffd, dummy3, dummy3d)
      IF (d .EQ. 0.0) THEN
        dd = 0.0_8
      ELSE
        dd = dd/(2.0*SQRT(d))
      END IF
      d = SQRT(d)
      RETURN
    ELSE
      IF (a .LE. eps) THEN
        s = zero
        td = (fd*e-f*ed)/e**2
        t = f/e
        CALL CLAMP_D(t, td, zero, one)
        sd = 0.0_8
      ELSE
        CALL DOT_PROD_D(c, cd, d1, d1d, r, rd)
        IF (e .LE. eps) THEN
          t = zero
          sd = -((cd*a-c*ad)/a**2)
          s = -(c/a)
          CALL CLAMP_D(s, sd, zero, one)
          td = 0.0_8
        ELSE
! General non-degenerate case
          CALL DOT_PROD_D(b, bd, d1, d1d, d2, d2d)
          denomd = ad*e + a*ed - bd*b - b*bd
          denom = a*e - b*b
          IF (denom .NE. zero) THEN
            sd = ((bd*f+b*fd-cd*e-c*ed)*denom-(b*f-c*e)*denomd)/denom**2
            s = (b*f-c*e)/denom
            CALL CLAMP_D(s, sd, zero, one)
          ELSE
            s = zero
            sd = 0.0_8
          END IF
          td = ((bd*s+b*sd+fd)*e-(b*s+f)*ed)/e**2
          t = (b*s+f)/e
          IF (t .LT. zero) THEN
            t = zero
            sd = -((cd*a-c*ad)/a**2)
            s = -(c/a)
            CALL CLAMP_D(s, sd, zero, one)
            td = 0.0_8
          ELSE IF (t .GT. one) THEN
            t = one
            sd = ((bd-cd)*a-(b-c)*ad)/a**2
            s = (b-c)/a
            CALL CLAMP_D(s, sd, zero, one)
            td = 0.0_8
          END IF
        END IF
      END IF
      c1d = p1d + d1d*s + d1*sd
      c1 = p1 + d1*s
      c2d = p2d + d2d*t + d2*td
      c2 = p2 + d2*t
      diffd = c2d - c1d
      diff = c2 - c1
      dummy3d = diffd
      dummy3 = diff
      CALL DOT_PROD_D(d, dd, diff, diffd, dummy3, dummy3d)
      IF (d .EQ. 0.0) THEN
        dd = 0.0_8
      ELSE
        dd = dd/(2.0*SQRT(d))
      END IF
      d = SQRT(d)
      RETURN
    END IF
  END SUBROUTINE LINE_LINE_D
!  Differentiation of clamp in forward (tangent) mode:
!   variations   of useful results: n
!   with respect to varying inputs: n
  SUBROUTINE CLAMP_D(n, nd, min, max)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: min, max
    REAL(kind=8), INTENT(INOUT) :: n
    REAL(kind=8), INTENT(INOUT) :: nd
    IF (n .LT. min) THEN
      n = min
      nd = 0.0_8
    END IF
    IF (n .GT. max) THEN
      n = max
      nd = 0.0_8
    END IF
  END SUBROUTINE CLAMP_D
  SUBROUTINE LINE_LINE(p1, q1, p2, q2, d)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: p1, q1, p2, q2
    REAL(kind=8), INTENT(OUT) :: d
    REAL(kind=8), DIMENSION(3) :: d1, d2, r, diff, c1, c2, dummy3
    REAL(kind=8), PARAMETER :: eps=1e-12
    REAL(kind=8) :: a, b, c, e, f, s, t, denom
    INTRINSIC SQRT
    d1 = q1 - p1
    d2 = q2 - p2
    r = p1 - p2
    dummy3 = d1
    CALL DOT_PROD(a, d1, dummy3)
    dummy3 = d2
    CALL DOT_PROD(e, d2, dummy3)
    CALL DOT_PROD(f, d2, r)
    IF (a .LE. eps .AND. e .LE. eps) THEN
! both segments degenrate into points
      diff = q1 - p1
      dummy3 = diff
      CALL DOT_PROD(d, diff, dummy3)
      d = SQRT(d)
      RETURN
    ELSE
      IF (a .LE. eps) THEN
        s = zero
        t = f/e
        CALL CLAMP(t, zero, one)
      ELSE
        CALL DOT_PROD(c, d1, r)
        IF (e .LE. eps) THEN
          t = zero
          s = -(c/a)
          CALL CLAMP(s, zero, one)
        ELSE
! General non-degenerate case
          CALL DOT_PROD(b, d1, d2)
          denom = a*e - b*b
          IF (denom .NE. zero) THEN
            s = (b*f-c*e)/denom
            CALL CLAMP(s, zero, one)
          ELSE
            s = zero
          END IF
          t = (b*s+f)/e
          IF (t .LT. zero) THEN
            t = zero
            s = -(c/a)
            CALL CLAMP(s, zero, one)
          ELSE IF (t .GT. one) THEN
            t = one
            s = (b-c)/a
            CALL CLAMP(s, zero, one)
          END IF
        END IF
      END IF
      c1 = p1 + d1*s
      c2 = p2 + d2*t
      diff = c2 - c1
      dummy3 = diff
      CALL DOT_PROD(d, diff, dummy3)
      d = SQRT(d)
      RETURN
    END IF
  END SUBROUTINE LINE_LINE
  SUBROUTINE CLAMP(n, min, max)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: min, max
    REAL(kind=8), INTENT(INOUT) :: n
    IF (n .LT. min) n = min
    IF (n .GT. max) n = max
  END SUBROUTINE CLAMP
  SUBROUTINE MAXLOC3(a, maxind)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: a
    INTEGER, INTENT(OUT) :: maxind
    IF (a(1) .GT. a(2)) THEN
      IF (a(1) .GT. a(3)) THEN
        maxind = 1
        RETURN
      ELSE
        maxind = 3
        RETURN
      END IF
    ELSE IF (a(2) .GT. a(3)) THEN
      maxind = 2
      RETURN
    ELSE
      maxind = 3
      RETURN
    END IF
  END SUBROUTINE MAXLOC3
!  Differentiation of intersect in forward (tangent) mode:
!   variations   of useful results: length
!   with respect to varying inputs: c1 c2 a1 a2 b1 b2
!   RW status of diff variables: c1:in c2:in length:out a1:in a2:in
!                b1:in b2:in
  SUBROUTINE INTERSECT_D(a1, a1d, b1, b1d, c1, c1d, a2, a2d, b2, b2d, c2&
&   , c2d, length, lengthd)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: a1, b1, c1, a2, b2, c2
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: a1d, b1d, c1d, a2d, b2d, &
&   c2d
    REAL(kind=8), INTENT(OUT) :: length
    REAL(kind=8), INTENT(OUT) :: lengthd
    REAL(kind=8), DIMENSION(3) :: n1, n2, d, absd
    REAL(kind=8), DIMENSION(3) :: n1d, n2d, dd
    REAL(kind=8), PARAMETER :: eps=1e-12
    REAL(kind=8) :: d1, da1, db1, dc1, pa1, pb1, pc1, t11, t12, t1high, &
&   t1low, dt
    REAL(kind=8) :: d1d, da1d, db1d, dc1d, pa1d, pb1d, pc1d, t11d, t12d&
&   , t1highd, t1lowd, dtd
    REAL(kind=8) :: d2, da2, db2, dc2, pa2, pb2, pc2, t21, t22, t2high, &
&   t2low
    REAL(kind=8) :: d2d, da2d, db2d, dc2d, pa2d, pb2d, pc2d, t21d, t22d&
&   , t2highd, t2lowd
    INTEGER :: lone_vertex_1, lone_vertex_2, maxind
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC SQRT
    REAL(kind=8) :: arg1
    REAL(kind=8) :: arg1d
    REAL(kind=8) :: result1
    REAL(kind=8) :: result1d
    REAL(kind=8) :: min1
    REAL(kind=8) :: min1d
    REAL(kind=8) :: max1d
    REAL(kind=8) :: max1
    CALL CROSS_PROD_D(n2, n2d, b2 - a2, b2d - a2d, c2 - a2, c2d - a2d)
    CALL DOT_PROD_D(d2, d2d, n2, n2d, a2, a2d)
    d2d = -d2d
    d2 = -d2
    CALL DOT_PROD_D(da1, da1d, n2, n2d, a1, a1d)
    da1d = da1d + d2d
    da1 = da1 + d2
    CALL DOT_PROD_D(db1, db1d, n2, n2d, b1, b1d)
    db1d = db1d + d2d
    db1 = db1 + d2
    CALL DOT_PROD_D(dc1, dc1d, n2, n2d, c1, c1d)
    dc1d = dc1d + d2d
    dc1 = dc1 + d2
    IF (da1 .GE. zero .AND. db1 .GE. zero .AND. dc1 .GE. zero) THEN
      length = 0.0
      lengthd = 0.0_8
      RETURN
    ELSE IF (da1 .LE. zero .AND. db1 .LE. zero .AND. dc1 .LE. zero) THEN
      length = 0.0
      lengthd = 0.0_8
      RETURN
    ELSE
! general case
      CALL CROSS_PROD_D(n1, n1d, b1 - a1, b1d - a1d, c1 - a1, c1d - a1d)
      CALL DOT_PROD_D(d1, d1d, n1, n1d, a1, a1d)
      d1d = -d1d
      d1 = -d1
      CALL DOT_PROD_D(da2, da2d, n1, n1d, a2, a2d)
      da2d = da2d + d1d
      da2 = da2 + d1
      CALL DOT_PROD_D(db2, db2d, n1, n1d, b2, b2d)
      db2d = db2d + d1d
      db2 = db2 + d1
      CALL DOT_PROD_D(dc2, dc2d, n1, n1d, c2, c2d)
      dc2d = dc2d + d1d
      dc2 = dc2 + d1
      IF (da2 .GE. zero .AND. db2 .GE. zero .AND. dc2 .GE. zero) THEN
        length = 0.0
        lengthd = 0.0_8
        RETURN
      ELSE IF (da2 .LE. zero .AND. db2 .LE. zero .AND. dc2 .LE. zero) &
&     THEN
        length = 0.0
        lengthd = 0.0_8
        RETURN
      ELSE
        CALL CROSS_PROD_D(d, dd, n1, n1d, n2, n2d)
! absd = abs(d)
! call maxloc3(absd, maxind)
! pa1 = a1(maxind)
! pb1 = b1(maxind)
! pc1 = c1(maxind)
        CALL DOT_PROD_D(pa1, pa1d, d, dd, a1, a1d)
        CALL DOT_PROD_D(pb1, pb1d, d, dd, b1, b1d)
        CALL DOT_PROD_D(pc1, pc1d, d, dd, c1, c1d)
! need to figure out which vertex is by itself
        IF (da1 .GT. 0) THEN
          IF (db1 .GT. 0) THEN
            lone_vertex_1 = 3
          ELSE IF (dc1 .GT. 0) THEN
            lone_vertex_1 = 2
          ELSE
            lone_vertex_1 = 1
          END IF
        ELSE IF (db1 .LT. 0) THEN
          lone_vertex_1 = 3
        ELSE IF (dc1 .LT. 0) THEN
          lone_vertex_1 = 2
        ELSE
          lone_vertex_1 = 1
        END IF
        IF (lone_vertex_1 .EQ. 1) THEN
          t11d = pb1d + (((pa1d-pb1d)*db1+(pa1-pb1)*db1d)*(db1-da1)-(pa1&
&           -pb1)*db1*(db1d-da1d))/(db1-da1)**2
          t11 = pb1 + (pa1-pb1)*db1/(db1-da1)
          t12d = pc1d + (((pa1d-pc1d)*dc1+(pa1-pc1)*dc1d)*(dc1-da1)-(pa1&
&           -pc1)*dc1*(dc1d-da1d))/(dc1-da1)**2
          t12 = pc1 + (pa1-pc1)*dc1/(dc1-da1)
        ELSE IF (lone_vertex_1 .EQ. 2) THEN
          t11d = pa1d + (((pb1d-pa1d)*da1+(pb1-pa1)*da1d)*(da1-db1)-(pb1&
&           -pa1)*da1*(da1d-db1d))/(da1-db1)**2
          t11 = pa1 + (pb1-pa1)*da1/(da1-db1)
          t12d = pc1d + (((pb1d-pc1d)*dc1+(pb1-pc1)*dc1d)*(dc1-db1)-(pb1&
&           -pc1)*dc1*(dc1d-db1d))/(dc1-db1)**2
          t12 = pc1 + (pb1-pc1)*dc1/(dc1-db1)
        ELSE
          t11d = pa1d + (((pc1d-pa1d)*da1+(pc1-pa1)*da1d)*(da1-dc1)-(pc1&
&           -pa1)*da1*(da1d-dc1d))/(da1-dc1)**2
          t11 = pa1 + (pc1-pa1)*da1/(da1-dc1)
          t12d = pb1d + (((pc1d-pb1d)*db1+(pc1-pb1)*db1d)*(db1-dc1)-(pc1&
&           -pb1)*db1*(db1d-dc1d))/(db1-dc1)**2
          t12 = pb1 + (pc1-pb1)*db1/(db1-dc1)
        END IF
        CALL DOT_PROD_D(pa2, pa2d, d, dd, a2, a2d)
        CALL DOT_PROD_D(pb2, pb2d, d, dd, b2, b2d)
        CALL DOT_PROD_D(pc2, pc2d, d, dd, c2, c2d)
! need to figure out which vertex is by itself
        IF (da2 .GT. 0) THEN
          IF (db2 .GT. 0) THEN
            lone_vertex_2 = 3
          ELSE IF (dc2 .GT. 0) THEN
            lone_vertex_2 = 2
          ELSE
            lone_vertex_2 = 1
          END IF
        ELSE IF (db2 .LT. 0) THEN
          lone_vertex_2 = 3
        ELSE IF (dc2 .LT. 0) THEN
          lone_vertex_2 = 2
        ELSE
          lone_vertex_2 = 1
        END IF
        IF (lone_vertex_2 .EQ. 1) THEN
          t21d = pb2d + (((pa2d-pb2d)*db2+(pa2-pb2)*db2d)*(db2-da2)-(pa2&
&           -pb2)*db2*(db2d-da2d))/(db2-da2)**2
          t21 = pb2 + (pa2-pb2)*db2/(db2-da2)
          t22d = pc2d + (((pa2d-pc2d)*dc2+(pa2-pc2)*dc2d)*(dc2-da2)-(pa2&
&           -pc2)*dc2*(dc2d-da2d))/(dc2-da2)**2
          t22 = pc2 + (pa2-pc2)*dc2/(dc2-da2)
        ELSE IF (lone_vertex_2 .EQ. 2) THEN
          t21d = pa2d + (((pb2d-pa2d)*da2+(pb2-pa2)*da2d)*(da2-db2)-(pb2&
&           -pa2)*da2*(da2d-db2d))/(da2-db2)**2
          t21 = pa2 + (pb2-pa2)*da2/(da2-db2)
          t22d = pc2d + (((pb2d-pc2d)*dc2+(pb2-pc2)*dc2d)*(dc2-db2)-(pb2&
&           -pc2)*dc2*(dc2d-db2d))/(dc2-db2)**2
          t22 = pc2 + (pb2-pc2)*dc2/(dc2-db2)
        ELSE
          t21d = pa2d + (((pc2d-pa2d)*da2+(pc2-pa2)*da2d)*(da2-dc2)-(pc2&
&           -pa2)*da2*(da2d-dc2d))/(da2-dc2)**2
          t21 = pa2 + (pc2-pa2)*da2/(da2-dc2)
          t22d = pb2d + (((pc2d-pb2d)*db2+(pc2-pb2)*db2d)*(db2-dc2)-(pc2&
&           -pb2)*db2*(db2d-dc2d))/(db2-dc2)**2
          t22 = pb2 + (pc2-pb2)*db2/(db2-dc2)
        END IF
        IF (t11 .GT. t12) THEN
          t1highd = t11d
          t1high = t11
          t1lowd = t12d
          t1low = t12
        ELSE
          t1highd = t12d
          t1high = t12
          t1lowd = t11d
          t1low = t11
        END IF
        IF (t21 .GT. t22) THEN
          t2highd = t21d
          t2high = t21
          t2lowd = t22d
          t2low = t22
        ELSE
          t2highd = t22d
          t2high = t22
          t2lowd = t21d
          t2low = t21
        END IF
! check if intervals overlap
        IF (t1high .LT. t2low .OR. t2high .LT. t1low) THEN
! no overlap
          length = 0.0
          lengthd = 0.0_8
          RETURN
        ELSE
          IF (t1high .GT. t2high) THEN
            min1d = t2highd
            min1 = t2high
          ELSE
            min1d = t1highd
            min1 = t1high
          END IF
          IF (t1low .LT. t2low) THEN
            max1d = t2lowd
            max1 = t2low
          ELSE
            max1d = t1lowd
            max1 = t1low
          END IF
          dtd = min1d - max1d
          dt = min1 - max1
          arg1d = 2*d(1)*dd(1) + 2*d(2)*dd(2) + 2*d(3)*dd(3)
          arg1 = d(1)**2 + d(2)**2 + d(3)**2
          IF (arg1 .EQ. 0.0) THEN
            result1d = 0.0_8
          ELSE
            result1d = arg1d/(2.0*SQRT(arg1))
          END IF
          result1 = SQRT(arg1)
          lengthd = (dtd*result1-dt*result1d)/result1**2
          length = dt/result1
          RETURN
        END IF
      END IF
    END IF
  END SUBROUTINE INTERSECT_D
!  Differentiation of dot_prod in forward (tangent) mode:
!   variations   of useful results: d
!   with respect to varying inputs: v w
  SUBROUTINE DOT_PROD_D(d, dd, v, vd, w, wd)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: v, w
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: vd, wd
    REAL(kind=8), INTENT(OUT) :: d
    REAL(kind=8), INTENT(OUT) :: dd
    dd = vd(1)*w(1) + v(1)*wd(1) + vd(2)*w(2) + v(2)*wd(2) + vd(3)*w(3) &
&     + v(3)*wd(3)
    d = v(1)*w(1) + v(2)*w(2) + v(3)*w(3)
  END SUBROUTINE DOT_PROD_D
!  Differentiation of cross_prod in forward (tangent) mode:
!   variations   of useful results: x
!   with respect to varying inputs: u v
  SUBROUTINE CROSS_PROD_D(x, xd, u, ud, v, vd)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: u, v
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: ud, vd
    REAL(kind=8), DIMENSION(3), INTENT(OUT) :: x
    REAL(kind=8), DIMENSION(3), INTENT(OUT) :: xd
    xd = 0.0_8
    xd(1) = ud(2)*v(3) + u(2)*vd(3) - ud(3)*v(2) - u(3)*vd(2)
    x(1) = u(2)*v(3) - u(3)*v(2)
    xd(2) = ud(3)*v(1) + u(3)*vd(1) - ud(1)*v(3) - u(1)*vd(3)
    x(2) = u(3)*v(1) - u(1)*v(3)
    xd(3) = ud(1)*v(2) + u(1)*vd(2) - ud(2)*v(1) - u(2)*vd(1)
    x(3) = u(1)*v(2) - u(2)*v(1)
  END SUBROUTINE CROSS_PROD_D
  SUBROUTINE INTERSECT(a1, b1, c1, a2, b2, c2, length)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: a1, b1, c1, a2, b2, c2
    REAL(kind=8), INTENT(OUT) :: length
    REAL(kind=8), DIMENSION(3) :: n1, n2, d, absd
    REAL(kind=8), PARAMETER :: eps=1e-12
    REAL(kind=8) :: d1, da1, db1, dc1, pa1, pb1, pc1, t11, t12, t1high, &
&   t1low, dt
    REAL(kind=8) :: d2, da2, db2, dc2, pa2, pb2, pc2, t21, t22, t2high, &
&   t2low
    INTEGER :: lone_vertex_1, lone_vertex_2, maxind
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC SQRT
    REAL(kind=8) :: arg1
    REAL(kind=8) :: result1
    REAL(kind=8) :: min1
    REAL(kind=8) :: max1
    CALL CROSS_PROD(n2, b2 - a2, c2 - a2)
    CALL DOT_PROD(d2, n2, a2)
    d2 = -d2
    CALL DOT_PROD(da1, n2, a1)
    da1 = da1 + d2
    CALL DOT_PROD(db1, n2, b1)
    db1 = db1 + d2
    CALL DOT_PROD(dc1, n2, c1)
    dc1 = dc1 + d2
    IF (da1 .GE. zero .AND. db1 .GE. zero .AND. dc1 .GE. zero) THEN
      length = 0.0
      RETURN
    ELSE IF (da1 .LE. zero .AND. db1 .LE. zero .AND. dc1 .LE. zero) THEN
      length = 0.0
      RETURN
    ELSE
! general case
      CALL CROSS_PROD(n1, b1 - a1, c1 - a1)
      CALL DOT_PROD(d1, n1, a1)
      d1 = -d1
      CALL DOT_PROD(da2, n1, a2)
      da2 = da2 + d1
      CALL DOT_PROD(db2, n1, b2)
      db2 = db2 + d1
      CALL DOT_PROD(dc2, n1, c2)
      dc2 = dc2 + d1
      IF (da2 .GE. zero .AND. db2 .GE. zero .AND. dc2 .GE. zero) THEN
        length = 0.0
        RETURN
      ELSE IF (da2 .LE. zero .AND. db2 .LE. zero .AND. dc2 .LE. zero) &
&     THEN
        length = 0.0
        RETURN
      ELSE
        CALL CROSS_PROD(d, n1, n2)
! absd = abs(d)
! call maxloc3(absd, maxind)
! pa1 = a1(maxind)
! pb1 = b1(maxind)
! pc1 = c1(maxind)
        CALL DOT_PROD(pa1, d, a1)
        CALL DOT_PROD(pb1, d, b1)
        CALL DOT_PROD(pc1, d, c1)
! need to figure out which vertex is by itself
        IF (da1 .GT. 0) THEN
          IF (db1 .GT. 0) THEN
            lone_vertex_1 = 3
          ELSE IF (dc1 .GT. 0) THEN
            lone_vertex_1 = 2
          ELSE
            lone_vertex_1 = 1
          END IF
        ELSE IF (db1 .LT. 0) THEN
          lone_vertex_1 = 3
        ELSE IF (dc1 .LT. 0) THEN
          lone_vertex_1 = 2
        ELSE
          lone_vertex_1 = 1
        END IF
        IF (lone_vertex_1 .EQ. 1) THEN
          t11 = pb1 + (pa1-pb1)*db1/(db1-da1)
          t12 = pc1 + (pa1-pc1)*dc1/(dc1-da1)
        ELSE IF (lone_vertex_1 .EQ. 2) THEN
          t11 = pa1 + (pb1-pa1)*da1/(da1-db1)
          t12 = pc1 + (pb1-pc1)*dc1/(dc1-db1)
        ELSE
          t11 = pa1 + (pc1-pa1)*da1/(da1-dc1)
          t12 = pb1 + (pc1-pb1)*db1/(db1-dc1)
        END IF
        CALL DOT_PROD(pa2, d, a2)
        CALL DOT_PROD(pb2, d, b2)
        CALL DOT_PROD(pc2, d, c2)
! need to figure out which vertex is by itself
        IF (da2 .GT. 0) THEN
          IF (db2 .GT. 0) THEN
            lone_vertex_2 = 3
          ELSE IF (dc2 .GT. 0) THEN
            lone_vertex_2 = 2
          ELSE
            lone_vertex_2 = 1
          END IF
        ELSE IF (db2 .LT. 0) THEN
          lone_vertex_2 = 3
        ELSE IF (dc2 .LT. 0) THEN
          lone_vertex_2 = 2
        ELSE
          lone_vertex_2 = 1
        END IF
        IF (lone_vertex_2 .EQ. 1) THEN
          t21 = pb2 + (pa2-pb2)*db2/(db2-da2)
          t22 = pc2 + (pa2-pc2)*dc2/(dc2-da2)
        ELSE IF (lone_vertex_2 .EQ. 2) THEN
          t21 = pa2 + (pb2-pa2)*da2/(da2-db2)
          t22 = pc2 + (pb2-pc2)*dc2/(dc2-db2)
        ELSE
          t21 = pa2 + (pc2-pa2)*da2/(da2-dc2)
          t22 = pb2 + (pc2-pb2)*db2/(db2-dc2)
        END IF
        IF (t11 .GT. t12) THEN
          t1high = t11
          t1low = t12
        ELSE
          t1high = t12
          t1low = t11
        END IF
        IF (t21 .GT. t22) THEN
          t2high = t21
          t2low = t22
        ELSE
          t2high = t22
          t2low = t21
        END IF
! check if intervals overlap
        IF (t1high .LT. t2low .OR. t2high .LT. t1low) THEN
! no overlap
          length = 0.0
          RETURN
        ELSE
          IF (t1high .GT. t2high) THEN
            min1 = t2high
          ELSE
            min1 = t1high
          END IF
          IF (t1low .LT. t2low) THEN
            max1 = t2low
          ELSE
            max1 = t1low
          END IF
          dt = min1 - max1
          arg1 = d(1)**2 + d(2)**2 + d(3)**2
          result1 = SQRT(arg1)
          length = dt/result1
          RETURN
        END IF
      END IF
    END IF
  END SUBROUTINE INTERSECT
  SUBROUTINE DOT_PROD(d, v, w)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: v, w
    REAL(kind=8), INTENT(OUT) :: d
    d = v(1)*w(1) + v(2)*w(2) + v(3)*w(3)
  END SUBROUTINE DOT_PROD
  SUBROUTINE CROSS_PROD(x, u, v)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: u, v
    REAL(kind=8), DIMENSION(3), INTENT(OUT) :: x
    x(1) = u(2)*v(3) - u(3)*v(2)
    x(2) = u(3)*v(1) - u(1)*v(3)
    x(3) = u(1)*v(2) - u(2)*v(1)
  END SUBROUTINE CROSS_PROD
END MODULE TRIANGLES_D
