!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
!
MODULE TRIANGLES_B
  IMPLICIT NONE
  REAL(kind=8), PARAMETER :: one=1.0
  REAL(kind=8), PARAMETER :: zero=0.0

CONTAINS
!  Differentiation of point_tri in reverse (adjoint) mode:
!   gradient     of useful results: d p a b c
!   with respect to varying inputs: d p a b c
!   RW status of diff variables: d:in-zero p:incr a:incr b:incr
!                c:incr
  SUBROUTINE POINT_TRI_B(a, ab0, b, bb, c, cb, p, pb, d, db)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: a, b, c, p
    REAL(kind=8), DIMENSION(3) :: ab0, bb, cb, pb
    REAL(kind=8) :: d
    REAL(kind=8) :: db
    REAL(kind=8), DIMENSION(3) :: ab, ac, ap, bp, cp, closepoint, diff, &
&   dummydiff
    REAL(kind=8), DIMENSION(3) :: abb, acb, apb, bpb, cpb, closepointb, &
&   diffb, dummydiffb
    REAL(kind=8) :: d1, d2, d3, d4, d5, d6
    REAL(kind=8) :: d1b, d2b, d3b, d4b, d5b, d6b
    REAL(kind=8) :: v, vc, vb, va, w, denom
    REAL(kind=8) :: vb0, vcb, vbb, vab, wb, denomb
    INTRINSIC SQRT
    REAL(kind=8) :: tempb5
    REAL(kind=8) :: tempb4
    REAL(kind=8) :: tempb3
    REAL(kind=8) :: tempb2
    REAL(kind=8) :: tempb1
    REAL(kind=8) :: tempb0
    REAL(kind=8) :: tempb
    ab = b - a
    ac = c - a
    ap = p - a
    CALL DOT_PROD(d1, ab, ap)
    CALL DOT_PROD(d2, ac, ap)
    IF (d1 .LE. zero .AND. d2 .LE. zero) THEN
! barycentric 1, 0, 0
      closepoint = a
      diff = closepoint - p
      dummydiff = diff
      CALL DOT_PROD(d, diff, dummydiff)
      IF (d .EQ. 0.0) THEN
        db = 0.0
      ELSE
        db = db/(2.0*SQRT(d))
      END IF
      diffb = 0.0_8
      dummydiffb = 0.0_8
      CALL DOT_PROD_B(d, db, diff, diffb, dummydiff, dummydiffb)
      diffb = diffb + dummydiffb
      closepointb = 0.0_8
      closepointb = diffb
      pb = pb - diffb
      ab0 = ab0 + closepointb
      abb = 0.0_8
      acb = 0.0_8
      d1b = 0.0_8
      d2b = 0.0_8
    ELSE
! check if P in vertex region outside B
      bp = p - b
      CALL DOT_PROD(d3, ab, bp)
      CALL DOT_PROD(d4, ac, bp)
      IF (d3 .GE. zero .AND. d4 .LE. d3) THEN
! barycentric 0, 1, 0
        closepoint = b
        diff = closepoint - p
        dummydiff = diff
        CALL DOT_PROD(d, diff, dummydiff)
        IF (d .EQ. 0.0) THEN
          db = 0.0
        ELSE
          db = db/(2.0*SQRT(d))
        END IF
        diffb = 0.0_8
        dummydiffb = 0.0_8
        CALL DOT_PROD_B(d, db, diff, diffb, dummydiff, dummydiffb)
        diffb = diffb + dummydiffb
        closepointb = 0.0_8
        closepointb = diffb
        pb = pb - diffb
        bb = bb + closepointb
        abb = 0.0_8
        acb = 0.0_8
        d1b = 0.0_8
        d2b = 0.0_8
        d3b = 0.0_8
        d4b = 0.0_8
      ELSE
! check if P in edge region of AB, if so return projection of P onto AB
        vc = d1*d4 - d3*d2
        IF (vc .LE. zero .AND. d1 .GE. zero .AND. d3 .LE. zero) THEN
          v = d1/(d1-d3)
! barycentric coordinates (1-v,v,0)
          closepoint = a + v*ab
          diff = closepoint - p
          dummydiff = diff
          CALL DOT_PROD(d, diff, dummydiff)
          IF (d .EQ. 0.0) THEN
            db = 0.0
          ELSE
            db = db/(2.0*SQRT(d))
          END IF
          diffb = 0.0_8
          dummydiffb = 0.0_8
          CALL DOT_PROD_B(d, db, diff, diffb, dummydiff, dummydiffb)
          diffb = diffb + dummydiffb
          closepointb = 0.0_8
          closepointb = diffb
          pb = pb - diffb
          abb = 0.0_8
          ab0 = ab0 + closepointb
          vb0 = SUM(ab*closepointb)
          abb = v*closepointb
          tempb = vb0/(d1-d3)
          tempb0 = -(d1*tempb/(d1-d3))
          d1b = tempb0 + tempb
          d3b = -tempb0
          acb = 0.0_8
          d2b = 0.0_8
          d4b = 0.0_8
          vcb = 0.0_8
        ELSE
! Check if P in vertex region C
          cp = p - c
          CALL DOT_PROD(d5, ab, cp)
          CALL DOT_PROD(d6, ac, cp)
          IF (d6 .GE. zero .AND. d5 .LE. d6) THEN
! barycentric coordinates (0,0,1)
            closepoint = c
            diff = closepoint - p
            dummydiff = diff
            CALL DOT_PROD(d, diff, dummydiff)
            IF (d .EQ. 0.0) THEN
              db = 0.0
            ELSE
              db = db/(2.0*SQRT(d))
            END IF
            diffb = 0.0_8
            dummydiffb = 0.0_8
            CALL DOT_PROD_B(d, db, diff, diffb, dummydiff, dummydiffb)
            diffb = diffb + dummydiffb
            closepointb = 0.0_8
            closepointb = diffb
            pb = pb - diffb
            cb = cb + closepointb
            abb = 0.0_8
            acb = 0.0_8
            d1b = 0.0_8
            d2b = 0.0_8
            d3b = 0.0_8
            d4b = 0.0_8
            d5b = 0.0_8
            d6b = 0.0_8
            vcb = 0.0_8
          ELSE
! check if P in edge region of AC, if so, return proj(P,AC)
            vb = d5*d2 - d1*d6
            IF (vb .LE. zero .AND. d2 .GE. zero .AND. d6 .LE. zero) THEN
              w = d2/(d2-d6)
! barycentric (1-w, 0, w)
              closepoint = a + w*ac
              diff = closepoint - p
              dummydiff = diff
              CALL DOT_PROD(d, diff, dummydiff)
              IF (d .EQ. 0.0) THEN
                db = 0.0
              ELSE
                db = db/(2.0*SQRT(d))
              END IF
              diffb = 0.0_8
              dummydiffb = 0.0_8
              CALL DOT_PROD_B(d, db, diff, diffb, dummydiff, dummydiffb)
              diffb = diffb + dummydiffb
              closepointb = 0.0_8
              closepointb = diffb
              pb = pb - diffb
              acb = 0.0_8
              ab0 = ab0 + closepointb
              wb = SUM(ac*closepointb)
              acb = w*closepointb
              tempb1 = wb/(d2-d6)
              tempb2 = -(d2*tempb1/(d2-d6))
              d2b = tempb2 + tempb1
              d6b = -tempb2
              abb = 0.0_8
              d3b = 0.0_8
              d4b = 0.0_8
              d5b = 0.0_8
              vbb = 0.0_8
              vcb = 0.0_8
            ELSE
! Check if P in edge region of BC, if so, return proj(P,BC)
              va = d3*d6 - d5*d4
              IF (va .LE. zero .AND. d4 - d3 .GE. zero .AND. d5 - d6 &
&                 .GE. zero) THEN
                w = (d4-d3)/(d4-d3+(d5-d6))
! barycentric (0, 1-w, w)
                closepoint = b + w*(c-b)
                diff = closepoint - p
                dummydiff = diff
                CALL DOT_PROD(d, diff, dummydiff)
                IF (d .EQ. 0.0) THEN
                  db = 0.0
                ELSE
                  db = db/(2.0*SQRT(d))
                END IF
                diffb = 0.0_8
                dummydiffb = 0.0_8
                CALL DOT_PROD_B(d, db, diff, diffb, dummydiff, &
&                         dummydiffb)
                diffb = diffb + dummydiffb
                closepointb = 0.0_8
                closepointb = diffb
                pb = pb - diffb
                bb = bb + closepointb - w*closepointb
                wb = SUM((c-b)*closepointb)
                cb = cb + w*closepointb
                tempb3 = wb/(d4-d3+d5-d6)
                tempb4 = -((d4-d3)*tempb3/(d4-d3+d5-d6))
                d4b = tempb4 + tempb3
                d3b = -tempb4 - tempb3
                d5b = tempb4
                d6b = -tempb4
                abb = 0.0_8
                acb = 0.0_8
                vab = 0.0_8
                vbb = 0.0_8
                vcb = 0.0_8
              ELSE
! P inside face region. Compute Q through barycentric (u, v, w)
                denom = one/(va+vb+vc)
                v = vb*denom
                w = vc*denom
                closepoint = a + ab*v + ac*w
                diff = closepoint - p
                dummydiff = diff
                CALL DOT_PROD(d, diff, dummydiff)
                IF (d .EQ. 0.0) THEN
                  db = 0.0
                ELSE
                  db = db/(2.0*SQRT(d))
                END IF
                diffb = 0.0_8
                dummydiffb = 0.0_8
                CALL DOT_PROD_B(d, db, diff, diffb, dummydiff, &
&                         dummydiffb)
                diffb = diffb + dummydiffb
                closepointb = 0.0_8
                closepointb = diffb
                pb = pb - diffb
                abb = 0.0_8
                acb = 0.0_8
                ab0 = ab0 + closepointb
                abb = v*closepointb
                vb0 = SUM(ab*closepointb)
                acb = w*closepointb
                wb = SUM(ac*closepointb)
                denomb = vb*vb0 + vc*wb
                tempb5 = -(one*denomb/(va+vb+vc)**2)
                vcb = tempb5 + denom*wb
                vbb = tempb5 + denom*vb0
                vab = tempb5
                d3b = 0.0_8
                d4b = 0.0_8
                d5b = 0.0_8
                d6b = 0.0_8
              END IF
              d3b = d3b + d6*vab
              d6b = d6b + d3*vab
              d5b = d5b - d4*vab
              d4b = d4b - d5*vab
              d2b = 0.0_8
            END IF
            d5b = d5b + d2*vbb
            d2b = d2b + d5*vbb
            d1b = -(d6*vbb)
            d6b = d6b - d1*vbb
          END IF
          cpb = 0.0_8
          CALL DOT_PROD_B(d6, d6b, ac, acb, cp, cpb)
          CALL DOT_PROD_B(d5, d5b, ab, abb, cp, cpb)
          pb = pb + cpb
          cb = cb - cpb
        END IF
        d1b = d1b + d4*vcb
        d4b = d4b + d1*vcb
        d3b = d3b - d2*vcb
        d2b = d2b - d3*vcb
      END IF
      bpb = 0.0_8
      CALL DOT_PROD_B(d4, d4b, ac, acb, bp, bpb)
      CALL DOT_PROD_B(d3, d3b, ab, abb, bp, bpb)
      pb = pb + bpb
      bb = bb - bpb
    END IF
    apb = 0.0_8
    CALL DOT_PROD_B(d2, d2b, ac, acb, ap, apb)
    CALL DOT_PROD_B(d1, d1b, ab, abb, ap, apb)
    pb = pb + apb
    ab0 = ab0 - acb - abb - apb
    cb = cb + acb
    bb = bb + abb
    db = 0.0_8
  END SUBROUTINE POINT_TRI_B
  SUBROUTINE POINT_TRI(a, b, c, p, d)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: a, b, c, p
    REAL(kind=8), INTENT(OUT) :: d
    REAL(kind=8), DIMENSION(3) :: ab, ac, ap, bp, cp, closepoint, diff, &
&   dummydiff
    REAL(kind=8) :: d1, d2, d3, d4, d5, d6
    REAL(kind=8) :: v, vc, vb, va, w, denom
    INTRINSIC SQRT
    ab = b - a
    ac = c - a
    ap = p - a
    CALL DOT_PROD(d1, ab, ap)
    CALL DOT_PROD(d2, ac, ap)
    IF (d1 .LE. zero .AND. d2 .LE. zero) THEN
! barycentric 1, 0, 0
      closepoint = a
      diff = closepoint - p
      dummydiff = diff
      CALL DOT_PROD(d, diff, dummydiff)
      d = SQRT(d)
      RETURN
    ELSE
! check if P in vertex region outside B
      bp = p - b
      CALL DOT_PROD(d3, ab, bp)
      CALL DOT_PROD(d4, ac, bp)
      IF (d3 .GE. zero .AND. d4 .LE. d3) THEN
! barycentric 0, 1, 0
        closepoint = b
        diff = closepoint - p
        dummydiff = diff
        CALL DOT_PROD(d, diff, dummydiff)
        d = SQRT(d)
        RETURN
      ELSE
! check if P in edge region of AB, if so return projection of P onto AB
        vc = d1*d4 - d3*d2
        IF (vc .LE. zero .AND. d1 .GE. zero .AND. d3 .LE. zero) THEN
          v = d1/(d1-d3)
! barycentric coordinates (1-v,v,0)
          closepoint = a + v*ab
          diff = closepoint - p
          dummydiff = diff
          CALL DOT_PROD(d, diff, dummydiff)
          d = SQRT(d)
          RETURN
        ELSE
! Check if P in vertex region C
          cp = p - c
          CALL DOT_PROD(d5, ab, cp)
          CALL DOT_PROD(d6, ac, cp)
          IF (d6 .GE. zero .AND. d5 .LE. d6) THEN
! barycentric coordinates (0,0,1)
            closepoint = c
            diff = closepoint - p
            dummydiff = diff
            CALL DOT_PROD(d, diff, dummydiff)
            d = SQRT(d)
            RETURN
          ELSE
! check if P in edge region of AC, if so, return proj(P,AC)
            vb = d5*d2 - d1*d6
            IF (vb .LE. zero .AND. d2 .GE. zero .AND. d6 .LE. zero) THEN
              w = d2/(d2-d6)
! barycentric (1-w, 0, w)
              closepoint = a + w*ac
              diff = closepoint - p
              dummydiff = diff
              CALL DOT_PROD(d, diff, dummydiff)
              d = SQRT(d)
              RETURN
            ELSE
! Check if P in edge region of BC, if so, return proj(P,BC)
              va = d3*d6 - d5*d4
              IF (va .LE. zero .AND. d4 - d3 .GE. zero .AND. d5 - d6 &
&                 .GE. zero) THEN
                w = (d4-d3)/(d4-d3+(d5-d6))
! barycentric (0, 1-w, w)
                closepoint = b + w*(c-b)
                diff = closepoint - p
                dummydiff = diff
                CALL DOT_PROD(d, diff, dummydiff)
                d = SQRT(d)
                RETURN
              ELSE
! P inside face region. Compute Q through barycentric (u, v, w)
                denom = one/(va+vb+vc)
                v = vb*denom
                w = vc*denom
                closepoint = a + ab*v + ac*w
                diff = closepoint - p
                dummydiff = diff
                CALL DOT_PROD(d, diff, dummydiff)
                d = SQRT(d)
                RETURN
              END IF
            END IF
          END IF
        END IF
      END IF
    END IF
  END SUBROUTINE POINT_TRI
!  Differentiation of line_line in reverse (adjoint) mode:
!   gradient     of useful results: d p1 p2 q1 q2
!   with respect to varying inputs: d p1 p2 q1 q2
!   RW status of diff variables: d:in-zero p1:incr p2:incr q1:incr
!                q2:incr
  SUBROUTINE LINE_LINE_B(p1, p1b, q1, q1b, p2, p2b, q2, q2b, d, db)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: p1, q1, p2, q2
    REAL(kind=8), DIMENSION(3) :: p1b, q1b, p2b, q2b
    REAL(kind=8) :: d
    REAL(kind=8) :: db
    REAL(kind=8), DIMENSION(3) :: d1, d2, r, diff, c1, c2, dummy3
    REAL(kind=8), DIMENSION(3) :: d1b, d2b, rb, diffb, c1b, c2b, dummy3b
    REAL(kind=8), PARAMETER :: eps=1e-12
    REAL(kind=8) :: a, b, c, e, f, s, t, denom
    REAL(kind=8) :: ab, bb, cb, eb, fb, sb, tb, denomb
    INTRINSIC SQRT
    INTEGER :: branch
    REAL(kind=8) :: tempb1
    REAL(kind=8) :: tempb0
    REAL(kind=8) :: tempb
    d1 = q1 - p1
    d2 = q2 - p2
    r = p1 - p2
    dummy3 = d1
    CALL DOT_PROD(a, d1, dummy3)
    dummy3 = d2
    CALL DOT_PROD(e, d2, dummy3)
    CALL DOT_PROD(f, d2, r)
    IF (a .LE. eps .AND. e .LE. eps) THEN
! both segments degenrate into points
      diff = q1 - p1
      dummy3 = diff
      CALL DOT_PROD(d, diff, dummy3)
      IF (d .EQ. 0.0) THEN
        db = 0.0
      ELSE
        db = db/(2.0*SQRT(d))
      END IF
      diffb = 0.0_8
      dummy3b = 0.0_8
      CALL DOT_PROD_B(d, db, diff, diffb, dummy3, dummy3b)
      diffb = diffb + dummy3b
      q1b = q1b + diffb
      p1b = p1b - diffb
      eb = 0.0_8
      fb = 0.0_8
      rb = 0.0_8
      d1b = 0.0_8
      d2b = 0.0_8
      ab = 0.0_8
    ELSE
      IF (a .LE. eps) THEN
        s = zero
        t = f/e
        CALL PUSHREAL8(t)
        CALL CLAMP(t, zero, one)
        CALL PUSHCONTROL3B(0)
      ELSE
        CALL DOT_PROD(c, d1, r)
        IF (e .LE. eps) THEN
          t = zero
          s = -(c/a)
          CALL PUSHREAL8(s)
          CALL CLAMP(s, zero, one)
          CALL PUSHCONTROL3B(1)
        ELSE
! General non-degenerate case
          CALL DOT_PROD(b, d1, d2)
          denom = a*e - b*b
          IF (denom .NE. zero) THEN
            s = (b*f-c*e)/denom
            CALL PUSHREAL8(s)
            CALL CLAMP(s, zero, one)
            CALL PUSHCONTROL1B(0)
          ELSE
            s = zero
            CALL PUSHCONTROL1B(1)
          END IF
          t = (b*s+f)/e
          IF (t .LT. zero) THEN
            t = zero
            CALL PUSHREAL8(s)
            s = -(c/a)
            CALL PUSHREAL8(s)
            CALL CLAMP(s, zero, one)
            CALL PUSHCONTROL3B(2)
          ELSE IF (t .GT. one) THEN
            t = one
            CALL PUSHREAL8(s)
            s = (b-c)/a
            CALL PUSHREAL8(s)
            CALL CLAMP(s, zero, one)
            CALL PUSHCONTROL3B(3)
          ELSE
            CALL PUSHCONTROL3B(4)
          END IF
        END IF
      END IF
      c1 = p1 + d1*s
      c2 = p2 + d2*t
      diff = c2 - c1
      dummy3 = diff
      CALL DOT_PROD(d, diff, dummy3)
      IF (d .EQ. 0.0) THEN
        db = 0.0
      ELSE
        db = db/(2.0*SQRT(d))
      END IF
      diffb = 0.0_8
      dummy3b = 0.0_8
      CALL DOT_PROD_B(d, db, diff, diffb, dummy3, dummy3b)
      diffb = diffb + dummy3b
      c1b = 0.0_8
      c2b = 0.0_8
      c2b = diffb
      c1b = -diffb
      d2b = 0.0_8
      p2b = p2b + c2b
      d2b = t*c2b
      tb = SUM(d2*c2b)
      d1b = 0.0_8
      p1b = p1b + c1b
      d1b = s*c1b
      sb = SUM(d1*c1b)
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(t)
          CALL CLAMP_B(t, tb, zero, one)
          fb = tb/e
          eb = -(f*tb/e**2)
          rb = 0.0_8
          ab = 0.0_8
          GOTO 100
        ELSE
          CALL POPREAL8(s)
          CALL CLAMP_B(s, sb, zero, one)
          cb = -(sb/a)
          ab = c*sb/a**2
          eb = 0.0_8
          fb = 0.0_8
        END IF
      ELSE
        IF (branch .EQ. 2) THEN
          CALL POPREAL8(s)
          CALL CLAMP_B(s, sb, zero, one)
          CALL POPREAL8(s)
          cb = -(sb/a)
          ab = c*sb/a**2
          sb = 0.0_8
          tb = 0.0_8
          bb = 0.0_8
        ELSE IF (branch .EQ. 3) THEN
          CALL POPREAL8(s)
          CALL CLAMP_B(s, sb, zero, one)
          CALL POPREAL8(s)
          tempb1 = sb/a
          bb = tempb1
          cb = -tempb1
          ab = -((b-c)*tempb1/a)
          sb = 0.0_8
          tb = 0.0_8
        ELSE
          ab = 0.0_8
          bb = 0.0_8
          cb = 0.0_8
        END IF
        tempb0 = tb/e
        bb = bb + s*tempb0
        sb = sb + b*tempb0
        fb = tempb0
        eb = -((b*s+f)*tempb0/e)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(s)
          CALL CLAMP_B(s, sb, zero, one)
          tempb = sb/denom
          bb = bb + f*tempb
          fb = fb + b*tempb
          cb = cb - e*tempb
          eb = eb - c*tempb
          denomb = -((b*f-c*e)*tempb/denom)
        ELSE
          denomb = 0.0_8
        END IF
        ab = ab + e*denomb
        eb = eb + a*denomb
        bb = bb - 2*b*denomb
        CALL DOT_PROD_B(b, bb, d1, d1b, d2, d2b)
      END IF
      rb = 0.0_8
      CALL DOT_PROD_B(c, cb, d1, d1b, r, rb)
    END IF
 100 CALL DOT_PROD_B(f, fb, d2, d2b, r, rb)
    dummy3 = d2
    dummy3b = 0.0_8
    CALL DOT_PROD_B(e, eb, d2, d2b, dummy3, dummy3b)
    d2b = d2b + dummy3b
    dummy3 = d1
    dummy3b = 0.0_8
    CALL DOT_PROD_B(a, ab, d1, d1b, dummy3, dummy3b)
    d1b = d1b + dummy3b
    p1b = p1b + rb - d1b
    p2b = p2b - d2b - rb
    q2b = q2b + d2b
    q1b = q1b + d1b
    db = 0.0_8
  END SUBROUTINE LINE_LINE_B
!  Differentiation of clamp in reverse (adjoint) mode:
!   gradient     of useful results: n
!   with respect to varying inputs: n
  SUBROUTINE CLAMP_B(n, nb, min, max)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: min, max
    REAL(kind=8), INTENT(INOUT) :: n
    REAL(kind=8) :: nb
    INTEGER :: branch
    IF (n .LT. min) THEN
      n = min
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (n .GT. max) nb = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) nb = 0.0_8
  END SUBROUTINE CLAMP_B
  SUBROUTINE LINE_LINE(p1, q1, p2, q2, d)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: p1, q1, p2, q2
    REAL(kind=8), INTENT(OUT) :: d
    REAL(kind=8), DIMENSION(3) :: d1, d2, r, diff, c1, c2, dummy3
    REAL(kind=8), PARAMETER :: eps=1e-12
    REAL(kind=8) :: a, b, c, e, f, s, t, denom
    INTRINSIC SQRT
    d1 = q1 - p1
    d2 = q2 - p2
    r = p1 - p2
    dummy3 = d1
    CALL DOT_PROD(a, d1, dummy3)
    dummy3 = d2
    CALL DOT_PROD(e, d2, dummy3)
    CALL DOT_PROD(f, d2, r)
    IF (a .LE. eps .AND. e .LE. eps) THEN
! both segments degenrate into points
      diff = q1 - p1
      dummy3 = diff
      CALL DOT_PROD(d, diff, dummy3)
      d = SQRT(d)
      RETURN
    ELSE
      IF (a .LE. eps) THEN
        s = zero
        t = f/e
        CALL CLAMP(t, zero, one)
      ELSE
        CALL DOT_PROD(c, d1, r)
        IF (e .LE. eps) THEN
          t = zero
          s = -(c/a)
          CALL CLAMP(s, zero, one)
        ELSE
! General non-degenerate case
          CALL DOT_PROD(b, d1, d2)
          denom = a*e - b*b
          IF (denom .NE. zero) THEN
            s = (b*f-c*e)/denom
            CALL CLAMP(s, zero, one)
          ELSE
            s = zero
          END IF
          t = (b*s+f)/e
          IF (t .LT. zero) THEN
            t = zero
            s = -(c/a)
            CALL CLAMP(s, zero, one)
          ELSE IF (t .GT. one) THEN
            t = one
            s = (b-c)/a
            CALL CLAMP(s, zero, one)
          END IF
        END IF
      END IF
      c1 = p1 + d1*s
      c2 = p2 + d2*t
      diff = c2 - c1
      dummy3 = diff
      CALL DOT_PROD(d, diff, dummy3)
      d = SQRT(d)
      RETURN
    END IF
  END SUBROUTINE LINE_LINE
  SUBROUTINE CLAMP(n, min, max)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: min, max
    REAL(kind=8), INTENT(INOUT) :: n
    IF (n .LT. min) n = min
    IF (n .GT. max) n = max
  END SUBROUTINE CLAMP
  SUBROUTINE MAXLOC3(a, maxind)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: a
    INTEGER, INTENT(OUT) :: maxind
    IF (a(1) .GT. a(2)) THEN
      IF (a(1) .GT. a(3)) THEN
        maxind = 1
        RETURN
      ELSE
        maxind = 3
        RETURN
      END IF
    ELSE IF (a(2) .GT. a(3)) THEN
      maxind = 2
      RETURN
    ELSE
      maxind = 3
      RETURN
    END IF
  END SUBROUTINE MAXLOC3
!  Differentiation of intersect in reverse (adjoint) mode:
!   gradient     of useful results: c1 c2 length a1 a2 b1 b2
!   with respect to varying inputs: c1 c2 length a1 a2 b1 b2
!   RW status of diff variables: c1:incr c2:incr length:in-zero
!                a1:incr a2:incr b1:incr b2:incr
  SUBROUTINE INTERSECT_B(a1, a1b, b1, b1b, c1, c1b, a2, a2b, b2, b2b, c2&
&   , c2b, length, lengthb)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: a1, b1, c1, a2, b2, c2
    REAL(kind=8), DIMENSION(3) :: a1b, b1b, c1b, a2b, b2b, c2b
    REAL(kind=8) :: length
    REAL(kind=8) :: lengthb
    REAL(kind=8), DIMENSION(3) :: n1, n2, d, absd
    REAL(kind=8), DIMENSION(3) :: n1b, n2b, db
    REAL(kind=8), PARAMETER :: eps=1e-12
    REAL(kind=8) :: d1, da1, db1, dc1, pa1, pb1, pc1, t11, t12, t1high, &
&   t1low, dt
    REAL(kind=8) :: d1b, da1b, db1b, dc1b, pa1b, pb1b, pc1b, t11b, t12b&
&   , t1highb, t1lowb, dtb
    REAL(kind=8) :: d2, da2, db2, dc2, pa2, pb2, pc2, t21, t22, t2high, &
&   t2low
    REAL(kind=8) :: d2b, da2b, db2b, dc2b, pa2b, pb2b, pc2b, t21b, t22b&
&   , t2highb, t2lowb
    INTEGER :: lone_vertex_1, lone_vertex_2, maxind
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC SQRT
    REAL(kind=8), DIMENSION(3) :: arg1
    REAL(kind=8), DIMENSION(3) :: arg1b
    REAL(kind=8), DIMENSION(3) :: arg2
    REAL(kind=8), DIMENSION(3) :: arg2b
    INTEGER :: branch
    REAL(kind=8) :: temp0
    REAL(kind=8) :: tempb9
    REAL(kind=8) :: tempb8
    REAL(kind=8) :: tempb7
    REAL(kind=8) :: tempb6
    REAL(kind=8) :: min1
    REAL(kind=8) :: tempb5
    REAL(kind=8) :: tempb4
    REAL(kind=8) :: tempb19
    REAL(kind=8) :: tempb3
    REAL(kind=8) :: tempb18
    REAL(kind=8) :: tempb2
    REAL(kind=8) :: tempb17
    REAL(kind=8) :: tempb1
    REAL(kind=8) :: tempb16
    REAL(kind=8) :: tempb0
    REAL(kind=8) :: tempb15
    REAL(kind=8) :: tempb14
    REAL(kind=8) :: tempb13
    REAL(kind=8) :: tempb12
    REAL(kind=8) :: tempb11
    REAL(kind=8) :: tempb10
    REAL(kind=8) :: min1b
    REAL(kind=8) :: max1b
    REAL(kind=8) :: tempb
    REAL(kind=8) :: temp
    REAL(kind=8) :: tempb23
    REAL(kind=8) :: tempb22
    REAL(kind=8) :: max1
    REAL(kind=8) :: tempb21
    REAL(kind=8) :: tempb20
    arg1(:) = b2 - a2
    arg2(:) = c2 - a2
    CALL CROSS_PROD(n2, arg1(:), arg2(:))
    CALL DOT_PROD(d2, n2, a2)
    d2 = -d2
    CALL DOT_PROD(da1, n2, a1)
    da1 = da1 + d2
    CALL DOT_PROD(db1, n2, b1)
    db1 = db1 + d2
    CALL DOT_PROD(dc1, n2, c1)
    dc1 = dc1 + d2
    IF (da1 .GE. zero .AND. db1 .GE. zero .AND. dc1 .GE. zero) THEN
      dc1b = 0.0_8
      da1b = 0.0_8
      n2b = 0.0_8
      db1b = 0.0_8
    ELSE IF (da1 .LE. zero .AND. db1 .LE. zero .AND. dc1 .LE. zero) THEN
      dc1b = 0.0_8
      da1b = 0.0_8
      n2b = 0.0_8
      db1b = 0.0_8
    ELSE
! general case
      arg1(:) = b1 - a1
      arg2(:) = c1 - a1
      CALL CROSS_PROD(n1, arg1(:), arg2(:))
      CALL DOT_PROD(d1, n1, a1)
      d1 = -d1
      CALL DOT_PROD(da2, n1, a2)
      da2 = da2 + d1
      CALL DOT_PROD(db2, n1, b2)
      db2 = db2 + d1
      CALL DOT_PROD(dc2, n1, c2)
      dc2 = dc2 + d1
      IF (da2 .GE. zero .AND. db2 .GE. zero .AND. dc2 .GE. zero) THEN
        dc1b = 0.0_8
        dc2b = 0.0_8
        da1b = 0.0_8
        da2b = 0.0_8
        n1b = 0.0_8
        n2b = 0.0_8
        db1b = 0.0_8
        db2b = 0.0_8
      ELSE IF (da2 .LE. zero .AND. db2 .LE. zero .AND. dc2 .LE. zero) &
&     THEN
        dc1b = 0.0_8
        dc2b = 0.0_8
        da1b = 0.0_8
        da2b = 0.0_8
        n1b = 0.0_8
        n2b = 0.0_8
        db1b = 0.0_8
        db2b = 0.0_8
      ELSE
        CALL CROSS_PROD(d, n1, n2)
! absd = abs(d)
! call maxloc3(absd, maxind)
! pa1 = a1(maxind)
! pb1 = b1(maxind)
! pc1 = c1(maxind)
        CALL DOT_PROD(pa1, d, a1)
        CALL DOT_PROD(pb1, d, b1)
        CALL DOT_PROD(pc1, d, c1)
! need to figure out which vertex is by itself
        IF (da1 .GT. 0) THEN
          IF (db1 .GT. 0) THEN
            lone_vertex_1 = 3
          ELSE IF (dc1 .GT. 0) THEN
            lone_vertex_1 = 2
          ELSE
            lone_vertex_1 = 1
          END IF
        ELSE IF (db1 .LT. 0) THEN
          lone_vertex_1 = 3
        ELSE IF (dc1 .LT. 0) THEN
          lone_vertex_1 = 2
        ELSE
          lone_vertex_1 = 1
        END IF
        IF (lone_vertex_1 .EQ. 1) THEN
          t11 = pb1 + (pa1-pb1)*db1/(db1-da1)
          t12 = pc1 + (pa1-pc1)*dc1/(dc1-da1)
          CALL PUSHCONTROL2B(0)
        ELSE IF (lone_vertex_1 .EQ. 2) THEN
          t11 = pa1 + (pb1-pa1)*da1/(da1-db1)
          t12 = pc1 + (pb1-pc1)*dc1/(dc1-db1)
          CALL PUSHCONTROL2B(1)
        ELSE
          t11 = pa1 + (pc1-pa1)*da1/(da1-dc1)
          t12 = pb1 + (pc1-pb1)*db1/(db1-dc1)
          CALL PUSHCONTROL2B(2)
        END IF
        CALL DOT_PROD(pa2, d, a2)
        CALL DOT_PROD(pb2, d, b2)
        CALL DOT_PROD(pc2, d, c2)
! need to figure out which vertex is by itself
        IF (da2 .GT. 0) THEN
          IF (db2 .GT. 0) THEN
            lone_vertex_2 = 3
          ELSE IF (dc2 .GT. 0) THEN
            lone_vertex_2 = 2
          ELSE
            lone_vertex_2 = 1
          END IF
        ELSE IF (db2 .LT. 0) THEN
          lone_vertex_2 = 3
        ELSE IF (dc2 .LT. 0) THEN
          lone_vertex_2 = 2
        ELSE
          lone_vertex_2 = 1
        END IF
        IF (lone_vertex_2 .EQ. 1) THEN
          t21 = pb2 + (pa2-pb2)*db2/(db2-da2)
          t22 = pc2 + (pa2-pc2)*dc2/(dc2-da2)
          CALL PUSHCONTROL2B(0)
        ELSE IF (lone_vertex_2 .EQ. 2) THEN
          t21 = pa2 + (pb2-pa2)*da2/(da2-db2)
          t22 = pc2 + (pb2-pc2)*dc2/(dc2-db2)
          CALL PUSHCONTROL2B(1)
        ELSE
          t21 = pa2 + (pc2-pa2)*da2/(da2-dc2)
          t22 = pb2 + (pc2-pb2)*db2/(db2-dc2)
          CALL PUSHCONTROL2B(2)
        END IF
        IF (t11 .GT. t12) THEN
          t1high = t11
          t1low = t12
          CALL PUSHCONTROL1B(0)
        ELSE
          t1high = t12
          t1low = t11
          CALL PUSHCONTROL1B(1)
        END IF
        IF (t21 .GT. t22) THEN
          t2high = t21
          t2low = t22
          CALL PUSHCONTROL1B(0)
        ELSE
          t2high = t22
          t2low = t21
          CALL PUSHCONTROL1B(1)
        END IF
! check if intervals overlap
        IF (t1high .LT. t2low .OR. t2high .LT. t1low) THEN
          db = 0.0_8
          t1highb = 0.0_8
          t2lowb = 0.0_8
          t2highb = 0.0_8
          t1lowb = 0.0_8
        ELSE
          IF (t1high .GT. t2high) THEN
            min1 = t2high
            CALL PUSHCONTROL1B(1)
          ELSE
            min1 = t1high
            CALL PUSHCONTROL1B(0)
          END IF
          IF (t1low .LT. t2low) THEN
            max1 = t2low
            CALL PUSHCONTROL1B(0)
          ELSE
            max1 = t1low
            CALL PUSHCONTROL1B(1)
          END IF
          dt = min1 - max1
          db = 0.0_8
          temp = d(1)**2 + d(2)**2 + d(3)**2
          temp0 = SQRT(temp)
          IF (temp .EQ. 0.0) THEN
            tempb23 = 0.0
          ELSE
            tempb23 = -(dt*lengthb/(temp0**3*2.0))
          END IF
          dtb = lengthb/temp0
          db(1) = db(1) + 2*d(1)*tempb23
          db(2) = db(2) + 2*d(2)*tempb23
          db(3) = db(3) + 2*d(3)*tempb23
          min1b = dtb
          max1b = -dtb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            t2lowb = max1b
            t1lowb = 0.0_8
          ELSE
            t1lowb = max1b
            t2lowb = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            t1highb = min1b
            t2highb = 0.0_8
          ELSE
            t2highb = min1b
            t1highb = 0.0_8
          END IF
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          t22b = t2lowb
          t21b = t2highb
        ELSE
          t21b = t2lowb
          t22b = t2highb
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          t12b = t1lowb
          t11b = t1highb
        ELSE
          t11b = t1lowb
          t12b = t1highb
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          tempb13 = t21b/(db2-da2)
          tempb14 = -((pa2-pb2)*db2*tempb13/(db2-da2))
          tempb11 = t22b/(dc2-da2)
          tempb12 = -((pa2-pc2)*dc2*tempb11/(dc2-da2))
          pc2b = t22b - dc2*tempb11
          pa2b = db2*tempb13 + dc2*tempb11
          dc2b = tempb12 + (pa2-pc2)*tempb11
          da2b = -tempb14 - tempb12
          pb2b = t21b - db2*tempb13
          db2b = tempb14 + (pa2-pb2)*tempb13
        ELSE IF (branch .EQ. 1) THEN
          tempb17 = t21b/(da2-db2)
          tempb18 = -((pb2-pa2)*da2*tempb17/(da2-db2))
          tempb15 = t22b/(dc2-db2)
          tempb16 = -((pb2-pc2)*dc2*tempb15/(dc2-db2))
          pc2b = t22b - dc2*tempb15
          pb2b = da2*tempb17 + dc2*tempb15
          dc2b = tempb16 + (pb2-pc2)*tempb15
          db2b = -tempb18 - tempb16
          pa2b = t21b - da2*tempb17
          da2b = tempb18 + (pb2-pa2)*tempb17
        ELSE
          tempb21 = t21b/(da2-dc2)
          tempb22 = -((pc2-pa2)*da2*tempb21/(da2-dc2))
          tempb19 = t22b/(db2-dc2)
          tempb20 = -((pc2-pb2)*db2*tempb19/(db2-dc2))
          pb2b = t22b - db2*tempb19
          pc2b = da2*tempb21 + db2*tempb19
          db2b = tempb20 + (pc2-pb2)*tempb19
          dc2b = -tempb22 - tempb20
          pa2b = t21b - da2*tempb21
          da2b = tempb22 + (pc2-pa2)*tempb21
        END IF
        CALL DOT_PROD_B(pc2, pc2b, d, db, c2, c2b)
        CALL DOT_PROD_B(pb2, pb2b, d, db, b2, b2b)
        CALL DOT_PROD_B(pa2, pa2b, d, db, a2, a2b)
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          tempb1 = t11b/(db1-da1)
          tempb2 = -((pa1-pb1)*db1*tempb1/(db1-da1))
          tempb = t12b/(dc1-da1)
          tempb0 = -((pa1-pc1)*dc1*tempb/(dc1-da1))
          pc1b = t12b - dc1*tempb
          pa1b = db1*tempb1 + dc1*tempb
          dc1b = tempb0 + (pa1-pc1)*tempb
          da1b = -tempb2 - tempb0
          pb1b = t11b - db1*tempb1
          db1b = tempb2 + (pa1-pb1)*tempb1
        ELSE IF (branch .EQ. 1) THEN
          tempb5 = t11b/(da1-db1)
          tempb6 = -((pb1-pa1)*da1*tempb5/(da1-db1))
          tempb3 = t12b/(dc1-db1)
          tempb4 = -((pb1-pc1)*dc1*tempb3/(dc1-db1))
          pc1b = t12b - dc1*tempb3
          pb1b = da1*tempb5 + dc1*tempb3
          dc1b = tempb4 + (pb1-pc1)*tempb3
          db1b = -tempb6 - tempb4
          pa1b = t11b - da1*tempb5
          da1b = tempb6 + (pb1-pa1)*tempb5
        ELSE
          tempb9 = t11b/(da1-dc1)
          tempb10 = -((pc1-pa1)*da1*tempb9/(da1-dc1))
          tempb7 = t12b/(db1-dc1)
          tempb8 = -((pc1-pb1)*db1*tempb7/(db1-dc1))
          pb1b = t12b - db1*tempb7
          pc1b = da1*tempb9 + db1*tempb7
          db1b = tempb8 + (pc1-pb1)*tempb7
          dc1b = -tempb10 - tempb8
          pa1b = t11b - da1*tempb9
          da1b = tempb10 + (pc1-pa1)*tempb9
        END IF
        CALL DOT_PROD_B(pc1, pc1b, d, db, c1, c1b)
        CALL DOT_PROD_B(pb1, pb1b, d, db, b1, b1b)
        CALL DOT_PROD_B(pa1, pa1b, d, db, a1, a1b)
        CALL CROSS_PROD_B(d, db, n1, n1b, n2, n2b)
      END IF
      d1b = db2b + da2b + dc2b
      CALL DOT_PROD_B(dc2, dc2b, n1, n1b, c2, c2b)
      CALL DOT_PROD_B(db2, db2b, n1, n1b, b2, b2b)
      CALL DOT_PROD_B(da2, da2b, n1, n1b, a2, a2b)
      d1b = -d1b
      CALL DOT_PROD_B(d1, d1b, n1, n1b, a1, a1b)
      CALL CROSS_PROD_B(n1, n1b, arg1(:), arg1b(:), arg2(:), arg2b(:))
      c1b = c1b + arg2b
      a1b = a1b - arg1b - arg2b
      b1b = b1b + arg1b
    END IF
    d2b = db1b + da1b + dc1b
    CALL DOT_PROD_B(dc1, dc1b, n2, n2b, c1, c1b)
    CALL DOT_PROD_B(db1, db1b, n2, n2b, b1, b1b)
    CALL DOT_PROD_B(da1, da1b, n2, n2b, a1, a1b)
    d2b = -d2b
    CALL DOT_PROD_B(d2, d2b, n2, n2b, a2, a2b)
    arg1(:) = b2 - a2
    arg2(:) = c2 - a2
    CALL CROSS_PROD_B(n2, n2b, arg1(:), arg1b(:), arg2(:), arg2b(:))
    c2b = c2b + arg2b
    a2b = a2b - arg1b - arg2b
    b2b = b2b + arg1b
    lengthb = 0.0_8
  END SUBROUTINE INTERSECT_B
!  Differentiation of dot_prod in reverse (adjoint) mode:
!   gradient     of useful results: d v w
!   with respect to varying inputs: v w
  SUBROUTINE DOT_PROD_B(d, db, v, vb, w, wb)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: v, w
    REAL(kind=8), DIMENSION(3) :: vb, wb
    REAL(kind=8) :: d
    REAL(kind=8) :: db
    vb(1) = vb(1) + w(1)*db
    wb(1) = wb(1) + v(1)*db
    vb(2) = vb(2) + w(2)*db
    wb(2) = wb(2) + v(2)*db
    vb(3) = vb(3) + w(3)*db
    wb(3) = wb(3) + v(3)*db
  END SUBROUTINE DOT_PROD_B
!  Differentiation of cross_prod in reverse (adjoint) mode:
!   gradient     of useful results: x
!   with respect to varying inputs: u v
  SUBROUTINE CROSS_PROD_B(x, xb, u, ub, v, vb)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: u, v
    REAL(kind=8), DIMENSION(3) :: ub, vb
    REAL(kind=8), DIMENSION(3) :: x
    REAL(kind=8), DIMENSION(3) :: xb
    ub = 0.0_8
    vb = 0.0_8
    ub(1) = ub(1) + v(2)*xb(3)
    vb(2) = vb(2) + u(1)*xb(3)
    ub(2) = ub(2) - v(1)*xb(3)
    vb(1) = vb(1) - u(2)*xb(3)
    xb(3) = 0.0_8
    ub(3) = ub(3) + v(1)*xb(2)
    vb(1) = vb(1) + u(3)*xb(2)
    ub(1) = ub(1) - v(3)*xb(2)
    vb(3) = vb(3) - u(1)*xb(2)
    xb(2) = 0.0_8
    ub(2) = ub(2) + v(3)*xb(1)
    vb(3) = vb(3) + u(2)*xb(1)
    ub(3) = ub(3) - v(2)*xb(1)
    vb(2) = vb(2) - u(3)*xb(1)
  END SUBROUTINE CROSS_PROD_B
  SUBROUTINE INTERSECT(a1, b1, c1, a2, b2, c2, length)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: a1, b1, c1, a2, b2, c2
    REAL(kind=8), INTENT(OUT) :: length
    REAL(kind=8), DIMENSION(3) :: n1, n2, d, absd
    REAL(kind=8), PARAMETER :: eps=1e-12
    REAL(kind=8) :: d1, da1, db1, dc1, pa1, pb1, pc1, t11, t12, t1high, &
&   t1low, dt
    REAL(kind=8) :: d2, da2, db2, dc2, pa2, pb2, pc2, t21, t22, t2high, &
&   t2low
    INTEGER :: lone_vertex_1, lone_vertex_2, maxind
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC SQRT
    REAL(kind=8), DIMENSION(3) :: arg1
    REAL(kind=8), DIMENSION(3) :: arg2
    REAL(kind=8) :: min1
    REAL(kind=8) :: max1
    arg1(:) = b2 - a2
    arg2(:) = c2 - a2
    CALL CROSS_PROD(n2, arg1(:), arg2(:))
    CALL DOT_PROD(d2, n2, a2)
    d2 = -d2
    CALL DOT_PROD(da1, n2, a1)
    da1 = da1 + d2
    CALL DOT_PROD(db1, n2, b1)
    db1 = db1 + d2
    CALL DOT_PROD(dc1, n2, c1)
    dc1 = dc1 + d2
    IF (da1 .GE. zero .AND. db1 .GE. zero .AND. dc1 .GE. zero) THEN
      length = 0.0
      RETURN
    ELSE IF (da1 .LE. zero .AND. db1 .LE. zero .AND. dc1 .LE. zero) THEN
      length = 0.0
      RETURN
    ELSE
! general case
      arg1(:) = b1 - a1
      arg2(:) = c1 - a1
      CALL CROSS_PROD(n1, arg1(:), arg2(:))
      CALL DOT_PROD(d1, n1, a1)
      d1 = -d1
      CALL DOT_PROD(da2, n1, a2)
      da2 = da2 + d1
      CALL DOT_PROD(db2, n1, b2)
      db2 = db2 + d1
      CALL DOT_PROD(dc2, n1, c2)
      dc2 = dc2 + d1
      IF (da2 .GE. zero .AND. db2 .GE. zero .AND. dc2 .GE. zero) THEN
        length = 0.0
        RETURN
      ELSE IF (da2 .LE. zero .AND. db2 .LE. zero .AND. dc2 .LE. zero) &
&     THEN
        length = 0.0
        RETURN
      ELSE
        CALL CROSS_PROD(d, n1, n2)
! absd = abs(d)
! call maxloc3(absd, maxind)
! pa1 = a1(maxind)
! pb1 = b1(maxind)
! pc1 = c1(maxind)
        CALL DOT_PROD(pa1, d, a1)
        CALL DOT_PROD(pb1, d, b1)
        CALL DOT_PROD(pc1, d, c1)
! need to figure out which vertex is by itself
        IF (da1 .GT. 0) THEN
          IF (db1 .GT. 0) THEN
            lone_vertex_1 = 3
          ELSE IF (dc1 .GT. 0) THEN
            lone_vertex_1 = 2
          ELSE
            lone_vertex_1 = 1
          END IF
        ELSE IF (db1 .LT. 0) THEN
          lone_vertex_1 = 3
        ELSE IF (dc1 .LT. 0) THEN
          lone_vertex_1 = 2
        ELSE
          lone_vertex_1 = 1
        END IF
        IF (lone_vertex_1 .EQ. 1) THEN
          t11 = pb1 + (pa1-pb1)*db1/(db1-da1)
          t12 = pc1 + (pa1-pc1)*dc1/(dc1-da1)
        ELSE IF (lone_vertex_1 .EQ. 2) THEN
          t11 = pa1 + (pb1-pa1)*da1/(da1-db1)
          t12 = pc1 + (pb1-pc1)*dc1/(dc1-db1)
        ELSE
          t11 = pa1 + (pc1-pa1)*da1/(da1-dc1)
          t12 = pb1 + (pc1-pb1)*db1/(db1-dc1)
        END IF
        CALL DOT_PROD(pa2, d, a2)
        CALL DOT_PROD(pb2, d, b2)
        CALL DOT_PROD(pc2, d, c2)
! need to figure out which vertex is by itself
        IF (da2 .GT. 0) THEN
          IF (db2 .GT. 0) THEN
            lone_vertex_2 = 3
          ELSE IF (dc2 .GT. 0) THEN
            lone_vertex_2 = 2
          ELSE
            lone_vertex_2 = 1
          END IF
        ELSE IF (db2 .LT. 0) THEN
          lone_vertex_2 = 3
        ELSE IF (dc2 .LT. 0) THEN
          lone_vertex_2 = 2
        ELSE
          lone_vertex_2 = 1
        END IF
        IF (lone_vertex_2 .EQ. 1) THEN
          t21 = pb2 + (pa2-pb2)*db2/(db2-da2)
          t22 = pc2 + (pa2-pc2)*dc2/(dc2-da2)
        ELSE IF (lone_vertex_2 .EQ. 2) THEN
          t21 = pa2 + (pb2-pa2)*da2/(da2-db2)
          t22 = pc2 + (pb2-pc2)*dc2/(dc2-db2)
        ELSE
          t21 = pa2 + (pc2-pa2)*da2/(da2-dc2)
          t22 = pb2 + (pc2-pb2)*db2/(db2-dc2)
        END IF
        IF (t11 .GT. t12) THEN
          t1high = t11
          t1low = t12
        ELSE
          t1high = t12
          t1low = t11
        END IF
        IF (t21 .GT. t22) THEN
          t2high = t21
          t2low = t22
        ELSE
          t2high = t22
          t2low = t21
        END IF
! check if intervals overlap
        IF (t1high .LT. t2low .OR. t2high .LT. t1low) THEN
! no overlap
          length = 0.0
          RETURN
        ELSE
          IF (t1high .GT. t2high) THEN
            min1 = t2high
          ELSE
            min1 = t1high
          END IF
          IF (t1low .LT. t2low) THEN
            max1 = t2low
          ELSE
            max1 = t1low
          END IF
          dt = min1 - max1
          length = dt/SQRT(d(1)**2+d(2)**2+d(3)**2)
          RETURN
        END IF
      END IF
    END IF
  END SUBROUTINE INTERSECT
  SUBROUTINE DOT_PROD(d, v, w)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: v, w
    REAL(kind=8), INTENT(OUT) :: d
    d = v(1)*w(1) + v(2)*w(2) + v(3)*w(3)
  END SUBROUTINE DOT_PROD
  SUBROUTINE CROSS_PROD(x, u, v)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(3), INTENT(IN) :: u, v
    REAL(kind=8), DIMENSION(3), INTENT(OUT) :: x
    x(1) = u(2)*v(3) - u(3)*v(2)
    x(2) = u(3)*v(1) - u(1)*v(3)
    x(3) = u(1)*v(2) - u(2)*v(1)
  END SUBROUTINE CROSS_PROD
END MODULE TRIANGLES_B
